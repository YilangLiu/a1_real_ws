#include "A1_dynamics.h"

A1_dynamics::A1_dynamics(){
    hip_offset_FL << 0.1805, 0.047, 0;
    hip_offset_FR << 0.1805, -0.047, 0;
    hip_offset_RL << -0.1805, 0.047, 0;
    hip_offset_RR << -0.1805, -0.047, 0;
}

void A1_dynamics::foot_position_in_hip_frame(Eigen::Matrix<double, 12, 1> motor_angle){
    for (int i = 0; i < 4;i++){
        // int i = swap_foot_indices(idx);

        Eigen::Vector3d foot_pos; 
        double theta_ab, theta_hip, theta_knee;
        theta_ab = motor_angle(3*i);
        theta_hip = motor_angle(3*i+1);
        theta_knee = motor_angle(3*i+2);
        int hip_sign = pow(-1, i);
        float l_hip = 0.0838 * hip_sign;
        double leg_distance = sqrt(pow(l_up,2) + pow(l_low,2)+ 2*l_up*l_low*cos(theta_knee));
        eff_swing = theta_hip + theta_knee /2;
        off_x_hip = -leg_distance*sin(eff_swing);
        off_z_hip = -leg_distance*cos(eff_swing);
        off_y_hip = l_hip;

        double off_x = off_x_hip;
        double off_y = cos(theta_ab) * off_y_hip - sin(theta_ab) * off_z_hip;
        double off_z = sin(theta_ab) * off_y_hip + cos(theta_ab) * off_z_hip;

        foot_pos << off_x, off_y, off_z;
        foot_position_rel.push_back(foot_pos);        
    }
}

void A1_dynamics::get_foot_position_base_frame(Eigen::Matrix<double, 12, 1> motor_angle){
    foot_position_rel.clear();
    foot_position_in_hip_frame(motor_angle);
    res_FL = foot_position_rel[0] + hip_offset_FL;
    res_FR = foot_position_rel[1] + hip_offset_FR;
    res_RL = foot_position_rel[2] + hip_offset_RL;
    res_RR = foot_position_rel[3] + hip_offset_RR;
}

Eigen::Matrix3d A1_dynamics::analytical_leg_jacobian(Eigen::Vector3d q, int leg_id){
    constexpr double l_up = 0.2;
    constexpr double l_low = 0.2;

    double l_hip = 0.0838 * std::pow(-1, leg_id);


    // if (leg_id==1){l_hip = 0.08505 * std::pow(-1, leg_id+1);}
    
    double t1 = q(0);
    double t2 = q(1);
    double t3 = q(2);

    double l_eff =  std::sqrt(l_up * l_up + l_low*l_low +2*l_up*l_low*std::cos(t3));
    double t_eff = t2 + t3/2;

    Eigen::Matrix3d J;

    J(0,0) = 0;
    J(0,1) = -l_eff *std::cos(t_eff);
    J(0,2) = l_low * l_up *std::sin(t3) * std::sin(t_eff)/l_eff - l_eff*std::cos(t_eff)/2;
    J(1,0) = -l_hip * std::sin(t1) + l_eff * std::cos(t1) * std::cos(t_eff);
    J(1, 1) = -l_eff * std::sin(t1) * std::sin(t_eff);
    J(1, 2) = -l_low * l_up * std::sin(t1) * std::sin(t3) * std::cos(t_eff) / l_eff - l_eff * std::sin(t1) * std::sin(t_eff) / 2;
    J(2, 0) = l_hip * std::cos(t1) + l_eff * std::sin(t1) * std::cos(t_eff);
    J(2, 1) = l_eff * std::sin(t_eff) * std::cos(t1);
    J(2, 2) = l_low * l_up * std::sin(t3) * std::cos(t1) * std::cos(t_eff) / l_eff + l_eff * std::sin(t_eff) * std::cos(t1) / 2;

    return J;
}

Eigen::Vector3d A1_dynamics::fk(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
    Eigen::Vector3d out;
    autoFunc_fk_derive(q.data(), rho_opt.data(), rho_fix.data(), out.data());
    return out;
}
Eigen::Matrix3d A1_dynamics::jac(Eigen::Vector3d q, Eigen::VectorXd rho_opt, Eigen::VectorXd rho_fix) {
    Eigen::Matrix3d mtx;
    autoFunc_d_fk_dq(q.data(), rho_opt.data(), rho_fix.data(), mtx.data());
    return mtx;
}

void A1_dynamics::autoFunc_fk_derive(const double in1[3], const double in2[3], const double
in3[5], double p_bf[3])
{
    double p_bf_tmp;
    double t2;
    double t3;
    double t4;
    double t5;
    double t6;
    double t7;
    double t8;
    double t9;

    //     This function was generated by the Symbolic Math Toolbox version 8.6.
    //     10-Aug-2021 14:48:21
    t2 = std::cos(in1[0]);
    t3 = std::cos(in1[1]);
    t4 = std::cos(in1[2]);
    t5 = std::sin(in1[0]);
    t6 = std::sin(in1[1]);
    t7 = std::sin(in1[2]);
    t8 = in1[1] + in1[2];
    t9 = std::sin(t8);
    p_bf[0] = (((in3[0] + in2[2] * t9) - in3[4] * t9) - t6 * in3[3]) + in2[0] *
                                                                       std::cos(t8);
    p_bf[1] = ((((((((in3[1] + in2[1] * t2) + in3[2] * t2) + t3 * t5 * in3[3]) +
                   in2[0] * t3 * t5 * t7) + in2[0] * t4 * t5 * t6) - in2[2] * t3 *
                                                                     t4 * t5) + in2[2] * t5 * t6 * t7) + in3[4] * t3 * t4 * t5) - in3
                                                                                                                                  [4] * t5 * t6 * t7;
    t8 = in2[0] * t2;
    t9 = in2[2] * t2;
    p_bf_tmp = in3[4] * t2;
    p_bf[2] = (((((((in2[1] * t5 + in3[2] * t5) - t2 * t3 * in3[3]) - t8 * t3 * t7)
                  - t8 * t4 * t6) + t9 * t3 * t4) - t9 * t6 * t7) - p_bf_tmp * t3 *
                                                                    t4) + p_bf_tmp * t6 * t7;
}

void A1_dynamics::autoFunc_d_fk_dq(const double in1[3], const double in2[3], const double
in3[5], double jacobian[9])
{
    double b_jacobian_tmp;
    double c_jacobian_tmp;
    double jacobian_tmp;
    double t12;
    double t16;
    double t17;
    double t2;
    double t22;
    double t3;
    double t4;
    double t5;
    double t6;
    double t7;
    double t8;
    double t9;

    //     This function was generated by the Symbolic Math Toolbox version 8.6.
    //     10-Aug-2021 14:48:21
    t2 = std::cos(in1[0]);
    t3 = std::cos(in1[1]);
    t4 = std::cos(in1[2]);
    t5 = std::sin(in1[0]);
    t6 = std::sin(in1[1]);
    t7 = std::sin(in1[2]);
    t8 = in1[1] + in1[2];
    t9 = std::cos(t8);
    t8 = std::sin(t8);
    t12 = in2[0] * t9;
    t16 = in2[2] * t8;
    t17 = in3[4] * t8;
    t22 = (t12 + t16) + -t17;
    jacobian[0] = 0.0;
    jacobian_tmp = in2[0] * t2;
    b_jacobian_tmp = in2[2] * t2;
    c_jacobian_tmp = in3[4] * t2;
    jacobian[1] = (((((((-in2[1] * t5 - in3[2] * t5) + t2 * t3 * in3[3]) +
                       jacobian_tmp * t3 * t7) + jacobian_tmp * t4 * t6) -
                     b_jacobian_tmp * t3 * t4) + b_jacobian_tmp * t6 * t7) +
                   c_jacobian_tmp * t3 * t4) - c_jacobian_tmp * t6 * t7;
    jacobian[2] = (((((((in2[1] * t2 + in3[2] * t2) + t3 * t5 * in3[3]) + in2[0] *
                                                                          t3 * t5 * t7) + in2[0] * t4 * t5 * t6) - in2[2] * t3 * t4 *
                                                                                                                   t5) + in2[2] * t5 * t6 * t7) + in3[4] * t3 * t4 * t5) - in3[4]
                                                                                                                                                                           * t5 * t6 * t7;
    jacobian_tmp = (in2[2] * t9 + -(in3[4] * t9)) + -(in2[0] * t8);
    jacobian[3] = jacobian_tmp - t3 * in3[3];
    b_jacobian_tmp = ((t6 * in3[3] - t12) - t16) + t17;
    jacobian[4] = -t5 * b_jacobian_tmp;
    jacobian[5] = t2 * b_jacobian_tmp;
    jacobian[6] = jacobian_tmp;
    jacobian[7] = t5 * t22;
    jacobian[8] = -t2 * t22;
}

Eigen::Vector3d A1_dynamics::foot_position_to_joint_angle(const Eigen::Vector3d foot_position, double l_hip_sign){
    double l_up = 0.2;
    double l_low = 0.2;
    double l_hip = 0.08505 * l_hip_sign;
    double x = foot_position[0];
    double y = foot_position[1];
    double z = foot_position[2];

    double theta_knee = -std::acos(
        (x * x + y * y + z * z - l_hip * l_hip - l_low * l_low - l_up * l_up) /
        (2 * l_low * l_up));

    double l = std::sqrt(l_up * l_up + l_low * l_low + 2 * l_up * l_low * std::cos(theta_knee));
    double theta_hip = std::asin(-x / l) - theta_knee / 2;

    double c1 = l_hip * y - l * std::cos(theta_hip + theta_knee / 2) * z;
    double s1 = l * std::cos(theta_hip + theta_knee / 2) * y + l_hip * z;

    double theta_ab = std::atan2(s1, c1);

    return Eigen::Vector3d(theta_ab, theta_hip, theta_knee);
    
}

Eigen::Vector3d A1_dynamics::get_joint_angle_FL(const Eigen::Vector3d foot_position){
    angle_FL = foot_position_to_joint_angle(foot_position - hip_offset_FL, 1);
    // angle_FR = foot_position_to_joint_angle(foot_position - hip_offset_FR, 1);
    // angle_RL = foot_position_to_joint_angle(foot_position - hip_offset_RL, 0);
    // angle_RR = foot_position_to_joint_angle(foot_position - hip_offset_RR, 1);
    return angle_FL;
}

Eigen::Vector3d A1_dynamics::get_joint_angle_FR(const Eigen::Vector3d foot_position){
    // angle_FL = foot_position_to_joint_angle(foot_position - hip_offset_FL, 0);
    angle_FR = foot_position_to_joint_angle(foot_position - hip_offset_FR, 1);
    // angle_RL = foot_position_to_joint_angle(foot_position - hip_offset_RL, 0);
    // angle_RR = foot_position_to_joint_angle(foot_position - hip_offset_RR, 1);
    return angle_FR;
}